"""Wrapper script to run RD-Agent with automatic code patching.

RD-Agent generates factor code with hardcoded Qlib paths. This wrapper:
1. Monitors the workspace for generated Python files
2. Patches them in real-time as they're created
3. Allows RD-Agent to run with corrected paths

This runs as a pre-execution hook before the actual rdagent command.
"""

import os
import sys
import time
from pathlib import Path
from typing import Optional

# Add parent to path to import patching logic
sys.path.insert(0, str(Path(__file__).parent))

from patch_generated_code import patch_generated_code_in_workspace


def monitor_and_patch_workspace(
    workspace_dir: str, qlib_data_path: str, poll_interval: float = 2.0
):
    """Monitor workspace and continuously patch generated files.

    This function runs in the background (or as part of setup) to ensure
    any Python files generated by RD-Agent are patched before execution.

    Args:
        workspace_dir: Path to RD-Agent workspace.
        qlib_data_path: The correct Qlib data path to use.
        poll_interval: How often to scan for new files (seconds).
    """
    workspace = Path(workspace_dir)
    patched_files = set()

    print(f"üîç Starting workspace monitor for: {workspace_dir}")
    print(f"   Qlib data path: {qlib_data_path}")

    # Initial patch of any existing files
    initial_count = patch_generated_code_in_workspace(workspace_dir, qlib_data_path)
    print(f"‚úÖ Initial patch: {initial_count} files")

    # Continue monitoring for new files (this is somewhat optional since
    # RD-Agent usually generates all code early, but good for robustness)
    max_iterations = 100  # Max 200 seconds of monitoring
    iteration = 0
    while iteration < max_iterations:
        iteration += 1
        time.sleep(poll_interval)

        # Find all Python files
        for py_file in workspace.rglob("*.py"):
            if (
                py_file not in patched_files
                and py_file.name != "patch_generated_code.py"
            ):
                if (
                    patch_generated_code_in_workspace(
                        str(py_file.parent), qlib_data_path
                    )
                    > 0
                ):
                    patched_files.add(py_file)
                    print(f"  ‚öôÔ∏è  Patched: {py_file.name}")


if __name__ == "__main__":
    if len(sys.argv) < 3:
        print("Usage: python patch_monitor.py <workspace_dir> <qlib_data_path>")
        sys.exit(1)

    ws_dir = sys.argv[1]
    qlib_path = sys.argv[2]

    # Patch once and return (the continuous monitoring would run in background)
    monitor_and_patch_workspace(ws_dir, qlib_path, poll_interval=0.5)
    print("‚ú® Patching complete.")
